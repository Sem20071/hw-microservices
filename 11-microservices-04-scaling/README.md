# Домашнее задание к занятию «Микросервисы: масштабирование»
Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры. Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.

## Задача 1: Кластеризация
Предложите решение для обеспечения развёртывания, запуска и управления приложениями. Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.
Решение должно соответствовать следующим требованиям:
- поддержка контейнеров;
- обеспечивать обнаружение сервисов и маршрутизацию запросов;
- обеспечивать возможность горизонтального масштабирования;
- обеспечивать возможность автоматического масштабирования;
- обеспечивать явное разделение ресурсов, доступных извне и внутри системы;
- обеспечивать возможность конфигурировать приложения с помощью переменных среды, в том числе с возможностью безопасного хранения чувствительных данных таких как пароли, ключи доступа, ключи шифрования и т. п.
Обоснуйте свой выбор.


## Ответ:

### Основное решение: Kubernetes
Kubernetes (K8s) — это открытая платформа для автоматизации развёртывания, масштабирования и управления контейнеризированными приложениями.

Как Kubernetes и сопутствующие инструменты покрывают ваши требования:
1. Поддержка контейнеров
- Kubernetes нативно работает с контейнерами, используя образы из любых реестров (Docker Hub, GitLab Container Registry, Harbor, AWS ECR и др.). Он абстрагирует работу с отдельными контейнерами, оперируя понятиями Pods (наименьшая единица развёртывания, которая может содержать один или несколько контейнеров) и Deployments (описывает желаемое состояние для пода и управляет его жизненным циклом).

2. Обнаружение сервисов и маршрутизация запросов
- Обнаружение сервисов: В Kubernetes для этого используется ресурс Service. Service создаёт стабильную конечную точку (DNS-имя и IP-адрес) для группы динамически меняющихся Pod'ов. Внутри кластера сервисы находят друг друга по DNS-именам (например, api-service.namespace.svc.cluster.local).
- Маршрутизация запросов: Для маршрутизации внешнего трафика внутрь кластера используется ресурс Ingress. Ingress не является сервисом, а представляет собой набор правил. Для его работы требуется Ingress Controller (например, NGINX Ingress Controller, Traefik, HAProxy). Ingress Controller — это работающий в кластере Pod, который смотрит на ресурсы Ingress и перенаправляет HTTP/HTTPS трафик на соответствующие сервисы.

3. Обеспечивать возможность горизонтального масштабирования
- Kubernetes позволяет вручную масштабировать количество реплик Pod'ов для любого Deployment.

4. Обеспечивать возможность автоматического масштабирования
- Для этого используется Horizontal Pod Autoscaler (HPA). HPA автоматически увеличивает или уменьшает количество Pod'ов в Deployment на основе заданной метрики (чаще всего — загрузки CPU или потребления памяти, но можно использовать и кастомные метрики).
- Для автоматического масштабирования самого кластера (добавления/удаления виртуальных машин) в облачных средах используется Cluster Autoscaler. Он отслеживает незапущенные Pod'ы из-за нехватки ресурсов и добавляет узлы в кластер (и наоборот, удаляет пустые узлы).

5. Обеспечивать явное разделение ресурсов, доступных извне и внутри системы
- Namespaces (Пространства имён): Это ключевой механизм изоляции в Kubernetes. Мы можем создать отдельные неймспейсы для разных сред (например, dev, staging, production) или для разных команд. Сетевые политики и политики безопасности могут быть привязаны к неймспейсам.
- Network Policies: Это ресурсы Kubernetes, которые позволяют управлять сетевым трафиком между Pod'ами. С их помощью можно реализовать модель "микросегментации", например, разрешить общение только между определенными сервисами и запретить прямой доступ к базам данных извне.
-  Service Types: Мы можем использовать:
-- Service type: ClusterIP (по умолчанию) — сервис доступен только внутри кластера.
-- Service type: LoadBalancer / Ingress — для предоставления доступа к сервисам из внешнего мира. Ingress является предпочтительным, так как позволяет централизованно управлять маршрутизацией на уровне L7 (HTTP/HTTPS).

6. Конфигурирование приложений и безопасное хранение чувствительных данных
ConfigMaps: Объект для хранения нефункциональных конфигурационных данных в виде пар "ключ-значение" (например, настройки логирования, URL внешних систем). Эти данные можно подключать к Pod'ам как переменные среды или как файлы.
Secrets: Объект для хранения чувствительных данных (пароли, OAuth-токены, SSH-ключи). Данные внутри хранятся в base64-кодировке (что не равно шифрованию).

Безопасность Secrets: Для обеспечения реальной безопасности необходимо:
1.Включить Encryption at Rest для etcd (хранилища данных K8s). Это зашифрует Secrets на диске.
2. Использовать внешние системы управления секретами, такие как HashiCorp Vault, AWS Secrets Manager, Azure Key Vault. Это наиболее безопасный и рекомендуемый подход. Существуют инструменты (например, External Secrets Operator), которые автоматически синхронизируют секреты из этих систем в Kubernetes Secrets.

#### Итоговое предложение по стеку технологий:
1. Оркестратор: Kubernetes.
Варианты развёртывания:
Управляемый сервис (предпочтительно): EKS (AWS), GKE (Google Cloud), AKS (Azure). Это избавляет от необходимости управлять control-plane.
Self-Hosted: kubeadm на собственных серверах или виртуальных машинах (больше контроля, но и больше операционных расходов).

2. Сеть и Ingress: NGINX Ingress Controller (проверенный, мощный, с большим количеством документации) или Traefik (более современный, с автоматическим обнаружением сервисов).

3. Автомасштабирование:
- HPA для автомасштабирования Pod'ов.
- Cluster Autoscaler для автомасштабирования узлов кластера (в облачной среде).

4. Безопасность и секреты:
- HashiCorp Vault как система управления секретами.
- External Secrets Operator для интеграции Vault с Kubernetes.

5. Мониторинг и логирование (критично для эксплуатации):
- Prometheus + Grafana для сбора метрик и визуализации.
- Loki + Grafana или EFK Stack (Elasticsearch, Fluentd, Kibana) для сбора и анализа логов.

6. CI/CD (для разработки):
- GitLab CI/CD, GitHub Actions или Argo CD для автоматизации процессов сборки, тестирования и развёртывания (GitOps-подход).

#### Обоснование выбора Kubernetes:
- Индустриальный стандарт: Наибольшее сообщество, поддержка всеми крупными облачными провайдерами, огромное количество готовых решений и документации.
- Идиоматичность для микросервисов: Его абстракции (Pods, Services, Deployments) идеально подходят для модели взаимодействия микросервисов.
- Расширяемость: Богатая экосистема инструментов (Operators, CRDs) позволяет адаптировать платформу под практически любые нужды.
- Портативность: Приложения, упакованные для K8s, могут быть запущены на любой его инсталляции — от локального миникуба до кластера в любом публичном или приватном облаке. Это решает проблему "работает на машине разработчика".
- Эффективное использование ресурсов: Благодаря оркестрации и автомасштабированию мы получаем высокую плотность размещения сервисов на инфраструктуре, что снижает costs.

#### Принцип взаимодействия:
Разработчик пушит код в Git -> CI/CD-пайплайн (например, GitLab CI) собирает образ контейнера и пушит его в реестр -> CI/CD-система или инструмент GitOps (например, Argo CD) обновляет манифест в Kubernetes -> Kubernetes видит изменение и производит "rolling update" приложения, поднимая новые Pod'ы с новой версией и удаляя старые. Всё это время Service обеспечивает стабильную маршрутизацию, а Ingress предоставляет доступ извне. HPA и Cluster Autoscaler следят за нагрузкой, а Vault безопасно предоставляет секреты.


